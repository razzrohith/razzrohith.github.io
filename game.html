<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Snake Game - Rajesh</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      color: #e2e8f0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      max-width: 800px;
      width: 100%;
      text-align: center;
    }

    h1 {
      font-size: clamp(2rem, 5vw, 3rem);
      margin-bottom: 10px;
      background: linear-gradient(90deg, #7c3aed, #3b82f6);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    p.subtitle {
      color: #94a3b8;
      margin-bottom: 30px;
      font-size: 1.1rem;
    }

    .game-wrapper {
      background: rgba(15, 23, 42, 0.8);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(124, 58, 237, 0.2);
      display: inline-block;
    }

    #gameCanvas {
      display: block;
      background: #0f172a;
      border-radius: 8px;
      border: 2px solid #334155;
      max-width: 100%;
      margin: 0 auto;
    }

    .stats {
      display: flex;
      justify-content: space-between;
      margin-top: 20px;
      gap: 20px;
    }

    .stat-box {
      flex: 1;
      background: rgba(30, 41, 59, 0.5);
      padding: 12px 20px;
      border-radius: 12px;
      border: 1px solid rgba(124, 58, 237, 0.2);
    }

    .stat-label {
      font-size: 0.85rem;
      color: #94a3b8;
      margin-bottom: 5px;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: #7c3aed;
    }

    .controls {
      margin-top: 25px;
    }

    .btn {
      background: linear-gradient(135deg, #7c3aed, #5b21b6);
      color: white;
      border: none;
      padding: 12px 30px;
      font-size: 1rem;
      font-weight: 600;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 8px 20px rgba(124, 58, 237, 0.3);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 28px rgba(124, 58, 237, 0.4);
    }

    .btn:active {
      transform: translateY(0);
    }

    .instructions {
      margin-top: 25px;
      color: #64748b;
      font-size: 0.95rem;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }

    .instructions kbd {
      background: #334155;
      padding: 3px 8px;
      border-radius: 6px;
      font-family: monospace;
      font-size: 0.85rem;
    }

    @media (max-width: 600px) {
      .stats {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Snake Game</h1>
    <p class="subtitle">A quick distraction while I rebuild the site</p>

    <div class="game-wrapper">
      <canvas id="gameCanvas" width="600" height="400"></canvas>

      <div class="stats">
        <div class="stat-box">
          <div class="stat-label">Score</div>
          <div class="stat-value" id="score">0</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">High Score</div>
          <div class="stat-value" id="highScore">0</div>
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="btn" id="restartBtn">Restart Game</button>
    </div>

    <div class="instructions">
      <p><strong>Controls:</strong> Use <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd> keys or swipe on touch devices.</p>
      <p style="margin-top: 8px;">Eat the food to grow. Don't hit the walls or yourself!</p>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('highScore');
    const restartBtn = document.getElementById('restartBtn');

    // Responsive canvas sizing
    function resizeCanvas() {
      const maxWidth = Math.min(window.innerWidth - 40, 600);
      const ratio = 400 / 600;
      canvas.width = maxWidth;
      canvas.height = maxWidth * ratio;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Game constants
    const gridSize = 20;
    let snake = [];
    let food = { x: 0, y: 0 };
    let direction = { x: 1, y: 0 };
    let nextDirection = { x: 1, y: 0 };
    let gameSpeed = 120;
    let score = 0;
    let highScore = localStorage.getItem('snakeHighScore') || 0;
    let gameLoop;
    let isGameRunning = false;

    highScoreEl.textContent = highScore;

    function initGame() {
      snake = [
        { x: 5, y: 2 },
        { x: 4, y: 2 },
        { x: 3, y: 2 }
      ];
      direction = { x: 1, y: 0 };
      nextDirection = { x: 1, y: 0 };
      score = 0;
      scoreEl.textContent = score;
      spawnFood();
      isGameRunning = true;
      if (gameLoop) clearInterval(gameLoop);
      gameLoop = setInterval(update, gameSpeed);
    }

    function spawnFood() {
      const cols = Math.floor(canvas.width / gridSize);
      const rows = Math.floor(canvas.height / gridSize);
      let valid = false;
      while (!valid) {
        food.x = Math.floor(Math.random() * cols);
        food.y = Math.floor(Math.random() * rows);
        valid = !snake.some(segment => segment.x === food.x && segment.y === food.y);
      }
    }

    function update() {
      direction = { ...nextDirection };
      const head = {
        x: snake[0].x + direction.x,
        y: snake[0].y + direction.y
      };

      // Check wall collision
      const cols = Math.floor(canvas.width / gridSize);
      const rows = Math.floor(canvas.height / gridSize);
      if (head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows) {
        gameOver();
        return;
      }

      // Check self collision
      if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
        gameOver();
        return;
      }

      snake.unshift(head);

      // Check food
      if (head.x === food.x && head.y === food.y) {
        score += 10;
        scoreEl.textContent = score;
        spawnFood();
        // Speed up slightly every 50 points
        if (score % 50 === 0 && gameSpeed > 60) {
          clearInterval(gameLoop);
          gameSpeed -= 10;
          gameLoop = setInterval(update, gameSpeed);
        }
      } else {
        snake.pop();
      }

      draw();
    }

    function draw() {
      const cols = Math.floor(canvas.width / gridSize);
      const rows = Math.floor(canvas.height / gridSize);

      // Clear
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw grid (subtle)
      ctx.strokeStyle = 'rgba(51, 65, 85, 0.3)';
      ctx.lineWidth = 0.5;
      for (let x = 0; x <= cols; x++) {
        ctx.beginPath();
        ctx.moveTo(x * gridSize, 0);
        ctx.lineTo(x * gridSize, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= rows; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * gridSize);
        ctx.lineTo(canvas.width, y * gridSize);
        ctx.stroke();
      }

      // Draw snake
      snake.forEach((segment, index) => {
        const brightness = 100 + (index * 2) % 56;
        ctx.fillStyle = index === 0
          ? '#7c3aed'
          : `hsl(${260 + (index * 1.5) % 60}, 70%, ${brightness}%)`;
        ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 2, gridSize - 2);

        // Eyes on head
        if (index === 0) {
          ctx.fillStyle = '#fff';
          const eyeSize = 4;
          const offset = 5;
          // Left eye
          ctx.fillRect(
            segment.x * gridSize + offset,
            segment.y * gridSize + offset,
            eyeSize, eyeSize
          );
          // Right eye
          ctx.fillRect(
            segment.x * gridSize + gridSize - offset - eyeSize,
            segment.y * gridSize + offset,
            eyeSize, eyeSize
          );
        }
      });

      // Draw food
      ctx.fillStyle = '#ef4444';
      ctx.beginPath();
      ctx.arc(
        food.x * gridSize + gridSize / 2,
        food.y * gridSize + gridSize / 2,
        gridSize / 2 - 2,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // Food glow
      ctx.shadowColor = '#ef4444';
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function gameOver() {
      isGameRunning = false;
      clearInterval(gameLoop);

      if (score > highScore) {
        highScore = score;
        localStorage.setItem('snakeHighScore', highScore);
        highScoreEl.textContent = highScore;
      }

      // Draw game over text
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 24px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over!', canvas.width / 2, canvas.height / 2 - 20);
      ctx.font = '16px system-ui';
      ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 10);
      if (score === highScore) {
        ctx.fillStyle = '#fbbf24';
        ctx.fillText('New High Score!', canvas.width / 2, canvas.height / 2 + 40);
      }
    }

    // Controls
    document.addEventListener('keydown', e => {
      if (!isGameRunning) {
        initGame();
        return;
      }

      const key = e.key;
      if (key === 'ArrowUp' && direction.y !== 1) nextDirection = { x: 0, y: -1 };
      if (key === 'ArrowDown' && direction.y !== -1) nextDirection = { x: 0, y: 1 };
      if (key === 'ArrowLeft' && direction.x !== 1) nextDirection = { x: -1, y: 0 };
      if (key === 'ArrowRight' && direction.x !== -1) nextDirection = { x: 1, y: 0 };
    });

    // Touch controls (swipe)
    let touchStartX = 0, touchStartY = 0;
    canvas.addEventListener('touchstart', e => {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }, { passive: true });

    canvas.addEventListener('touchend', e => {
      if (!isGameRunning) {
        initGame();
        return;
      }
      const dx = e.changedTouches[0].clientX - touchStartX;
      const dy = e.changedTouches[0].clientY - touchStartY;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 30 && direction.x !== -1) nextDirection = { x: 1, y: 0 };
        else if (dx < -30 && direction.x !== 1) nextDirection = { x: -1, y: 0 };
      } else {
        if (dy > 30 && direction.y !== -1) nextDirection = { x: 0, y: 1 };
        else if (dy < -30 && direction.y !== 1) nextDirection = { x: 0, y: -1 };
      }
    }, { passive: true });

    restartBtn.addEventListener('click', initGame);

    // Start game
    initGame();
  </script>
</body>
</html>
